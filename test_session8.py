import pytest
import random
import string
import session8
import os
import inspect
import re
from functools import reduce


README_CONTENT_CHECK_FOR = [ # not needed to check as these are not required to be named similar
    'length_check',
    'fib_generator',
    'operator_counter',
    'counter_for_user',
]

def test_readme_exists():
    assert os.path.isfile("README.md"), "README.md file missing!"

def test_readme_contents():
    """get file content"""
    readme = open("README.md", "r", encoding="utf-8")
    readme_words = readme.read().split()
    readme.close()
    assert len(readme_words) >= 500, "Make your README.md file interesting! Add atleast 500 words"

def test_readme_proper_description():
    READMELOOKSGOOD = True
    f = open("README.md", "r", encoding="utf-8")
    content = f.read()
    f.close()
    for c in README_CONTENT_CHECK_FOR:
        if c not in content:
            READMELOOKSGOOD = False
            pass
    assert READMELOOKSGOOD == True, "You have not described all the functions/class well in your README.md file"

def test_readme_file_for_formatting():
    f = open("README.md", "r", encoding="utf-8")
    content = f.read()
    f.close()
    assert content.count("#") >= 10

def test_indentations():
    ''' Returns pass if used four spaces for each level of syntactically \
    significant indenting.'''
    lines = inspect.getsource(session8)
    spaces = re.findall('\n +.', lines)
    for space in spaces:
        assert len(space) % 4 == 2, "Your script contains misplaced indentations"
        assert len(re.sub(r'[^ ]', '', space)) % 4 == 0, "Your code indentation does not follow PEP8 guidelines"

def test_function_name_had_cap_letter():
    functions = inspect.getmembers(session8, inspect.isfunction)
    for function in functions:
        assert len(re.findall('([A-Z])', function[0])) == 0, "You have used Capital letter(s) in your function names"


############################## session8 Validations#############################

# TODO: Test the closure that takes a function and then check whether the function
# passed has a docstring with more than 50 characters. 50 is stored as a free variable
def test_docstr_len_check_is_closure():
    """
    Test to check the docstr_len_check is a closure
    """
    assert hasattr(session8.docstr_len_check, '__closure__'), "docstr_len_check is not a valid closure"


def test_docstr_gt50_invalid_func():
    """
    Test to check function can handle invalid function call
    """
    with pytest.raises(NameError, match=r".*not a valid function'*"):
        session8.docstr_len_check(1) # 1 is not a callable function

def test_docstr_gt50_valid_func():
    """
    Test to check the doc string is greater than 50 characters for a callable function
    """
    # doc string for print is 392 char and hence result should be True
    assert session8.docstr_len_check(print) == True, "Length check is not working as expected"
    # doc string for test_readme_contents is less than 50 char and hence result should be False
    assert session8.docstr_len_check(test_readme_contents) == False, "Length check is not working as expected"
    # doc string for test_readme_exists doesn't exists and hence result should be true
    assert session8.docstr_len_check(test_readme_exists) == False, "Length check is not working as expected"


# TODO: Test the closure that gives you the next Fibonacci number

def test_next_fib_num_is_closure():
    """
    Test to check the next_fib_num is a closure
    """
    assert hasattr(session8.next_fib_num, '__closure__'), "next_fib_num is not a valid closure"

def test_next_fib_num_is_valid():
    """
    Test to check the numbers generated by next_fib_num is valid
    """
    # check the number generate by next fib number is a valid fibonacci number
    fib = lambda n: reduce(lambda x, _: x+[x[-1]+x[-2]], range(n-2), [0, 1])
    fib_list = fib(20)
    for _ in range(random.randint(1,20)): # 1,2,3,5,8
        result = session8.next_fib_num()
    assert result in set(fib_list), "Numbers generate are not in fibonacci series"


# TODO: Test the closure that can keep a track of how many times add/mul/div functions
#  were called, and update a global dictionary variable with the counts

def test_func_counter_is_closure():
    """
    Test to check the add_cntr, mul_cntr and div_cntr are valid closure
    """
    assert hasattr(session8.add_cntr, '__closure__'), "add_cntr is not a valid closure"
    assert hasattr(session8.mul_cntr, '__closure__'), "mul_cntr is not a valid closure"
    assert hasattr(session8.div_cntr, '__closure__'), "div_cntr is not a valid closure"


def test_func_counter_correct_update():
    """
    Test to check the valid update for counters in dictionary
    """
    cntr_add = 0
    cntr_mul = 0
    cntr_div = 0
    for _ in range(random.randint(1,10)): # Call add function random number of times
        cntr_add += 1
        # add random numbers betwee 1 to 100
        session8.add_cntr(random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call mul function random number of times
        cntr_mul += 1
        # mul random numbers betwee 1 to 100
        session8.mul_cntr(random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call div function random number of times
        cntr_div += 1
        # div to random numbers betwee 1 to 100
        session8.div_cntr(random.randint(1,100), random.randint(1,100))
    assert session8.operation['add']==cntr_add, "add_cntr is not updated properly in global dictionary counter"
    assert session8.operation['mul']==cntr_mul, "mul_cntr is not updated properly in global dictionary counter"
    assert session8.operation['div']==cntr_div, "div_cntr is not updated properly in global dictionary counter"


# TODO: Modify above such that now we can pass in different dictionary variables
# to update different dictionaries

def test_func_counter_is_closure():
    """
    Test to check the add_cntr, mul_cntr and div_cntr are valid closure
    """
    assert hasattr(session8.add_cntr1, '__closure__'), "add_cntr is not a valid closure"
    assert hasattr(session8.mul_cntr1, '__closure__'), "mul_cntr is not a valid closure"
    assert hasattr(session8.div_cntr1, '__closure__'), "div_cntr is not a valid closure"
    assert hasattr(session8.add_cntr2, '__closure__'), "add_cntr is not a valid closure"
    assert hasattr(session8.mul_cntr2, '__closure__'), "mul_cntr is not a valid closure"
    assert hasattr(session8.div_cntr2, '__closure__'), "div_cntr is not a valid closure"

def test_by_user_func_counter_correct_update():
    """
    Test to check the valid update for counters in user specific dictionary
    """
    # Counter for user 1
    cntr_add_1 = 0
    cntr_mul_1 = 0
    cntr_div_1 = 0

    # Counter for user 2
    cntr_add_2 = 0
    cntr_mul_2 = 0
    cntr_div_2 = 0

    for _ in range(random.randint(1,10)): # Call add function random number of times
        cntr_add_1 += 1
        # add random numbers betwee 1 to 100
        session8.add_cntr1(random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call mul function random number of times
        cntr_mul_1 += 1
        # mul random numbers betwee 1 to 100
        session8.mul_cntr1(random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call div function random number of times
        cntr_div_1 += 1
        # div to random numbers betwee 1 to 100
        session8.div_cntr1(random.randint(1,100), random.randint(1,100))

    for _ in range(random.randint(1,10)): # Call add function random number of times
        cntr_add_2 += 1
        # add random numbers betwee 1 to 100
        session8.add_cntr2(random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call mul function random number of times
        cntr_mul_2 += 1
        # mul random numbers betwee 1 to 100
        session8.mul_cntr2(random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call div function random number of times
        cntr_div_2 += 1
        # div to random numbers betwee 1 to 100
        session8.div_cntr2(random.randint(1,100), random.randint(1,100))

    assert session8.user1['add']==cntr_add_1, "add_cntr is not updated properly in user 1 dictionary counter"
    assert session8.user1['mul']==cntr_mul_1, "mul_cntr is not updated properly in user 1 dictionary counter"
    assert session8.user1['div']==cntr_div_1, "div_cntr is not updated properly in user 1 dictionary counter"

    assert session8.user2['add']==cntr_add_2, "add_cntr is not updated properly in user 2 dictionary counter"
    assert session8.user2['mul']==cntr_mul_2, "mul_cntr is not updated properly in user 2 dictionary counter"
    assert session8.user2['div']==cntr_div_2, "div_cntr is not updated properly in user 2 dictionary counter"


######################### TODO: Alternative approach############################
# Pass the fucntion name and arguments to the closure and update the global
# dictionary counter for specific users

def test_func_counter_is_closure_alt():
    """
    Test to check the add_cntr, mul_cntr and div_cntr are valid closure
    """
    assert hasattr(session8.optr1, '__closure__'), "add_cntr is not a valid closure"
    assert hasattr(session8.optr2, '__closure__'), "div_cntr is not a valid closure"

def test_by_user_func_counter_correct_update_alt():
    """
    Test to check the valid update for counters in user specific dictionary
    """
    # Counter for user 1
    cntr_add_1 = 0
    cntr_mul_1 = 0
    cntr_div_1 = 0

    # Counter for user 2
    cntr_add_2 = 0
    cntr_mul_2 = 0
    cntr_div_2 = 0

    for _ in range(random.randint(1,10)): # Call add function random number of times
        cntr_add_1 += 1
        # add random numbers betwee 1 to 100
        session8.optr1(session8.add,random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call mul function random number of times
        cntr_mul_1 += 1
        # mul random numbers betwee 1 to 100
        session8.optr1(session8.mul,random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call div function random number of times
        cntr_div_1 += 1
        # div to random numbers betwee 1 to 100
        session8.optr1(session8.div,random.randint(1,100), random.randint(1,100))

    for _ in range(random.randint(1,10)): # Call add function random number of times
        cntr_add_2 += 1
        # add random numbers betwee 1 to 100
        session8.optr2(session8.add,random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call mul function random number of times
        cntr_mul_2 += 1
        # mul random numbers betwee 1 to 100
        session8.optr2(session8.mul,random.randint(1,100), random.randint(1,100))
    for _ in range(random.randint(1,10)): # Call div function random number of times
        cntr_div_2 += 1
        # div to random numbers betwee 1 to 100
        session8.optr2(session8.div,random.randint(1,100), random.randint(1,100))

    assert session8.user1_alt['add']==cntr_add_1, "add_cntr is not updated properly in user 1 dictionary counter"
    assert session8.user1_alt['mul']==cntr_mul_1, "mul_cntr is not updated properly in user 1 dictionary counter"
    assert session8.user1_alt['div']==cntr_div_1, "div_cntr is not updated properly in user 1 dictionary counter"

    assert session8.user2_alt['add']==cntr_add_2, "add_cntr is not updated properly in user 2 dictionary counter"
    assert session8.user2_alt['mul']==cntr_mul_2, "mul_cntr is not updated properly in user 2 dictionary counter"
    assert session8.user2_alt['div']==cntr_div_2, "div_cntr is not updated properly in user 2 dictionary counter"
